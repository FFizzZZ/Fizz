```
class Solution:
    def maxInWindows(self, num, size):
        if not size: return []
        queue,res,i = [],[],0
        while i<len(num):
            if len(queue)>0 and i-size+1 > queue[0]: #若最大值queue[0]位置过期 则弹出 
                queue.pop(0)
            while len(queue)>0 and num[queue[-1]]<num[i]: #每次弹出所有比num[i]的数字
                queue.pop()
            queue.append(i)
            if i>=size-1:
                res.append(num[queue[0]])
            i += 1
        return res
```

```
class Solution:
    def maxInWindows(self, num, size):
        if not num or not size or len(num) < size: return []
        ans, queue = [], []
        for i in range(size):
            while queue and num[queue[-1]] <= num[i]:
                queue.pop()
            queue.append(i)
        ans.append(num[queue[0]])
        for i in range(size, len(num)):
            while queue and queue[0] < i - size + 1:
                queue.pop(0)
            while queue and num[queue[-1]] <= num[i]:
                queue.pop()
            queue.append(i)
            ans.append(num[queue[0]])
        return ans
```
