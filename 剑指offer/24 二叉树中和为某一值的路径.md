```
class Solution:
    def FindPath(self, root, expectNumber):
        # write code here
        ans = []
        def f(node, path, s):
            if not node: return
            if node.val == s and not node.right and not node.left:
                ans.append(path + [node.val])
            else:
                f(node.right, path+[node.val], s-node.val)
                f(node.left, path+[node.val], s-node.val)
        f(root, [], expectNumber)
        return sorted(ans, key=len, reverse=True)
```


```
class Solution:
    def FindPath(self, root, expectNumber):
        # write code here
        if not root or root.val > expectNumber:
            return []
        if not root.left and not root.right and root.val == expectNumber:
            return [[root.val]]
        else:
            expectNumber -= root.val
            left = self.FindPath(root.left,expectNumber)
            right = self.FindPath(root.right,expectNumber)
            
            result = [[root.val]+i for i in left]
            for i in right:
                result.append([root.val]+i)
        return sorted(result, key=lambda x:-len(x))
```
