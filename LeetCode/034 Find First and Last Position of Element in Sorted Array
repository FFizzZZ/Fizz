# slow 
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums: return [-1, -1]
        if len(nums) == 1:
            if nums[0] == target:
                return [0, 0]
            else:
                return [-1, -1]
        first, last = 0, len(nums) - 1
        index = -1
        while first <= last:
            mid = (first + last) // 2
            if nums[mid] == target:
                index = mid
            if nums[mid] < target:
                first += 1
            else:
                last -= 1
        if index == -1: return [-1, -1]
        res1 = res2 = index
        for i in range(index, 0, -1):
            if nums[i] != nums[i-1]:
                res1 = i
                break
        if res1 == 1 and nums[1] == nums[0]: res1 = 0
        for i in range(index, len(nums)-1):
            if nums[i] != nums[i+1]:
                res2 = i
                break
        if i == len(nums) - 2 and nums[-2] == nums[-1]: res2 = len(nums) - 1
        return [res1, res2]
                
            
            
------------------------

class Solution:
    # returns leftmost (or rightmost) index at which `target` should be inserted in sorted
    # array `nums` via binary search.
    def extreme_insertion_index(self, nums, target, left):
        lo = 0
        hi = len(nums)

        while lo < hi:
            mid = (lo + hi) // 2
            if nums[mid] > target or (left and target == nums[mid]):
                hi = mid
            else:
                lo = mid+1

        return lo


    def searchRange(self, nums, target):
        left_idx = self.extreme_insertion_index(nums, target, True)

        # assert that `left_idx` is within the array bounds and that `target`
        # is actually in `nums`.
        if left_idx == len(nums) or nums[left_idx] != target:
            return [-1, -1]

        return [left_idx, self.extreme_insertion_index(nums, target, False)-1]

----------------------------------------------------------------------
# Divide and Conquer
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums: return [-1, -1]
        def search(lo, hi):
            if nums[lo] == target == nums[hi]:
                return [lo, hi]
            if nums[lo] <= target <= nums[hi]:
                mid = (lo + hi) // 2
                l, r = search(lo, mid), search(mid+1, hi)
                return max(l, r) if -1 in l+r else [l[0], r[1]]
            return [-1, -1]
        return search(0, len(nums)-1)

---------------------------------------------------------------------

class Solution:
    def searchRange(self, nums, target):
        def search(n):
            lo, hi = 0, len(nums)
            while lo < hi:
                mid = (lo + hi) // 2
                if nums[mid] >= n:
                    hi = mid
                else:
                    lo = mid + 1
            return lo
        lo = search(target)
        return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1]











