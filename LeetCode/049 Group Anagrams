# 注意字典的key不能是可变的，所以用tuple
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = {}
        for i in strs:
            temp = tuple(sorted(i))
            if temp not in res:
                res[temp] = [i]
            else:
                res[temp].append(i)
        return list(res.values())

--------------------------------------

class Solution:
    def groupAnagrams(self, strs):
        ans = collections.defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            ans[tuple(count)].append(s)
        return list(ans.values())
        
class Solution:
    def groupAnagrams(self, strs):
        grouped = {}
        for s in strs:
            grouped.setdefault(''.join(sorted(s)), []).append(s)
        return list(grouped.values())
        
class Solution:
    def groupAnagrams(self, strs):
        ans = dict()
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            ans.setdefault(tuple(count), []).append(s)
        return list(ans.values())
        
class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        anas = {}
        for string in strs:
            s = ''.join(sorted(string))
            if s in anas:
                anas[s].append(string)
            else:
                anas[s] = [string]
        return list(anas.values())
        
        
        
算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。
利用这个，我们把每个字符串都映射到一个正数上。
用一个数组存储质数 prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103}。
然后每个字符串的字符减去 ' a ' ，然后取到 prime 中对应的质数。把它们累乘。
例如 abc ，就对应 'a' - 'a'， 'b' - 'a'， 'c' - 'a'，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 3 5 = 30，就把 "abc" 映射到了 30。
