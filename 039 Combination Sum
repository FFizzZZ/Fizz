class Solution(object):
    def combinationSum(self, candidates, target):
        result = []
        candidates = sorted(candidates)
        def dfs(remain, stack):
            if remain == 0:
                result.append(stack)
                return 

            for item in candidates:
                if item > remain: break
                if stack and item < stack[-1]: continue
                else:
                    dfs(remain - item, stack + [item])

        dfs(target, [])
        return result

-------------------

class Solution:
    def combinationSum(self, candidates, target):
        return self.combinationSum_helper(sorted(candidates), 0, target)

    def combinationSum_helper(self, candidates, i, target):
        if target==0: return [[]]
        ans = []
        for j in range(i,len(candidates)):
            x = candidates[j]
            if x > target: break
            tmp = self.combinationSum_helper(candidates, j , target-x)
            for l in tmp:
                l.insert(0,x)
            ans += tmp
        return ans
 -----------------------
 
 class Solution(object):
    def combinationSum(self, candidates, target):
        def dfs(candidates, start, target, path, res):
            if target == 0:
                return res.append(path + [])
            
            for i in range(start, len(candidates)):
                if target - candidates[i] >= 0:
                    path.append(candidates[i])
                    dfs(candidates, i, target - candidates[i], path, res)
                    path.pop()
        res = []
        dfs(candidates, 0, target, [], res)
        return res
